# Karonte 新固件分析流程指南

## 一、Karonte 工作原理概述

### 1.1 核心功能
Karonte 是一个用于检测嵌入式固件中**多二进制文件交互漏洞**的静态分析工具，基于 angr 二进制分析框架开发。

### 1.2 分析流程
```
固件镜像
    ↓
[1] 固件提取 (Firmware Extraction)
    ↓
[2] 边界二进制文件发现 (Border Binaries Finder - BBF)
    - 识别与网络/用户交互的二进制文件
    ↓
[3] 二进制依赖图构建 (Binary Dependency Graph - BDG)
    - 通过以下通信方式分析二进制文件间的依赖关系：
      * Environment variables (环境变量)
      * Files (文件系统)
      * Sockets (网络套接字)
      * Setter/Getter (设置/获取函数)
      * Semantic (语义分析)
    ↓
[4] 漏洞发现 (Bug Finder - BF)
    - 使用污点分析追踪不可信数据流
    - 检测缓冲区溢出、命令注入等漏洞
    ↓
分析报告
```

### 1.3 主要模块说明

| 模块 | 文件路径 | 功能 |
|------|---------|------|
| **BBF** | `tool/bbf/` | 边界二进制文件发现器，识别网络暴露的二进制文件 |
| **BDG** | `tool/bdg/` | 二进制依赖图构建器，分析进程间通信（IPC）机制 |
| **BF** | `tool/bf/` | 漏洞发现器，执行污点分析检测安全漏洞 |
| **CPFs** | `tool/bdg/cpfs/` | 通信模式查找器插件（Environment、File、Socket等）|

---

## 二、环境准备

### 2.1 依赖安装

```bash
# 1. 进入工具目录
cd tool/

# 2. 安装 Python 依赖
pip install -r requirements.txt
```

**主要依赖：**
- angr ~= 9.0.5739（二进制分析框架）
- claripy、archinfo、cle、pyvex（angr 相关组件）
- numpy、scikit-learn（机器学习库）
- networkx（图分析库）

### 2.2 验证安装

```bash
# 测试 angr 是否安装成功
python -c "import angr; print(angr.__version__)"
```

---

## 三、新固件准备流程

### 3.1 固件获取

1. **下载固件镜像**：从设备厂商官网获取固件文件
   - 示例：`MY_DEVICE_V1.0.bin`

2. **放置固件**：
   ```bash
   mkdir -p firmware/MY_VENDOR/MY_DEVICE
   cp MY_DEVICE_V1.0.bin firmware/MY_VENDOR/MY_DEVICE/
   ```

### 3.2 固件提取（自动或手动）

Karonte 支持两种方式：

#### 方式1：自动提取（推荐）
Karonte 使用内置的 FirmAE extractor 自动提取固件：
- 只需在配置文件中指定 `.bin` 文件路径
- Karonte 会自动解压到 `/tmp/fw/` 目录

#### 方式2：手动预提取
如果自动提取失败，可以使用 binwalk 手动提取：

```bash
# 安装 binwalk
sudo apt-get install binwalk

# 提取固件
cd firmware/MY_VENDOR/MY_DEVICE
binwalk -e MY_DEVICE_V1.0.bin

# 进入提取的文件系统根目录
cd _MY_DEVICE_V1.0.bin.extracted/squashfs-root
pwd  # 记录这个路径，用于配置文件
```

**预期结果：**
- 包含 `/bin`、`/sbin`、`/usr/bin` 等目录的文件系统

---

## 四、配置文件创建

### 4.1 创建配置文件

```bash
# 在 config 目录下为你的设备创建配置
mkdir -p config/MY_VENDOR
nano config/MY_VENDOR/my_device.json
```

### 4.2 配置文件模板

根据你的固件类型选择：

#### 【Linux 固件 - 自动提取】
```json
{
    "fw_path": "./firmware/MY_VENDOR/MY_DEVICE/MY_DEVICE_V1.0.bin",
    "bin": [],
    "pickle_parsers": "",
    "stats": "True",
    "data_keys": [],
    "angr_explode_bins": [
        "openvpn",
        "wpa_supplicant",
        "vpn",
        "dns",
        "ip",
        "log",
        "qemu-arm-static"
    ],
    "glob_var": [],
    "arch": "",
    "only_string": "False"
}
```

#### 【Linux 固件 - 手动提取】
```json
{
    "fw_path": "./firmware/MY_VENDOR/MY_DEVICE/_MY_DEVICE_V1.0.bin.extracted/squashfs-root",
    "bin": [],
    "pickle_parsers": "",
    "stats": "True",
    "data_keys": [],
    "angr_explode_bins": [
        "openvpn",
        "wpa_supplicant",
        "vpn",
        "dns",
        "ip",
        "log",
        "qemu-arm-static"
    ],
    "glob_var": [],
    "arch": "",
    "only_string": "False"
}
```

#### 【Blob 固件（bootloader/裸机）】
```json
{
    "fw_path": "",
    "bin": ["./firmware/MY_VENDOR/MY_DEVICE/bootloader.img"],
    "base_addr": "0x80000000",
    "eg_source_addr": "0x80001234",
    "arch": "ARM",
    "pickle_parsers": "",
    "stats": "True",
    "data_keys": [["0x80005000", "MMIO"]],
    "angr_explode_bins": [],
    "glob_var": ["0x80010000"],
    "only_string": "True"
}
```

### 4.3 配置参数说明

| 参数 | 必填 | 说明 | 示例值 |
|------|------|------|--------|
| **fw_path** | Linux固件必填 | 固件文件系统根目录路径 | `"./firmware/.../squashfs-root"` |
| **bin** | Blob固件必填 | 指定要分析的二进制文件列表（留空则自动发现）| `[]` 或 `["./firmware/bin1"]` |
| **pickle_parsers** | 可选 | 预先缓存的边界二进制解析器文件路径 | `""` 或 `"./pickles/parser/xxx.pk"` |
| **stats** | 必填 | 是否记录详细统计信息 | `"True"` / `"False"` |
| **data_keys** | Blob可选 | 用户输入来源的内存地址 | `[["0x7090530", "emmc"]]` |
| **base_addr** | Blob必填 | 二进制文件的加载基址（十六进制字符串）| `"0x80000000"` |
| **eg_source_addr** | Blob必填 | 引入用户输入的函数地址 | `"0x80001234"` |
| **arch** | Blob必填 | 处理器架构 | `"ARM"` / `"AARCH64"` / `"MIPS"` |
| **angr_explode_bins** | 可选 | angr 无法处理的二进制文件黑名单 | `["openvpn", "vpn"]` |
| **glob_var** | 可选 | 已知包含用户输入的全局变量地址 | `["0x80010000"]` |
| **only_string** | 可选 | 是否只考虑 data_keys 指定的数据 | `"False"` |

---

## 五、运行分析

### 5.1 基本运行命令

```bash
# 从项目根目录运行
python tool/karonte.py config/MY_VENDOR/my_device.json
```

### 5.2 指定日志输出路径

```bash
python tool/karonte.py config/MY_VENDOR/my_device.json /path/to/my_results.txt
```

**默认日志路径：** `/tmp/Karonte.txt_<随机数>`

### 5.3 运行过程监控

分析过程中会显示：
```
[Karonte] Logging at: /tmp/Karonte.txt_42
[Karonte] Firmware directory: /tmp/fw/MY_DEVICE
[Karonte] Retrieving Border Binaries
[Karonte] Generating Binary Dependency Graph
[Karonte] Discovering Binary Dependency Graph
[Karonte] Discovering Bugs
[Karonte] Finished, results in /tmp/Karonte.txt_42
```

**预计运行时间：** 根据固件复杂度，从几分钟到几小时不等。

---

## 六、结果分析

### 6.1 查看原始日志

```bash
cat /tmp/Karonte.txt_42
```

### 6.2 使用可视化工具（如果存在）

```bash
# 检查是否有 pretty_print 或可视化脚本
ls tool/
ls karonte-viz/

# 如果有可视化脚本
python karonte-viz/viz-results.py /tmp/Karonte.txt_42
```

### 6.3 日志内容解读

日志通常包含：

1. **边界二进制文件列表**
   ```
   Border Binaries Found:
   - /usr/bin/httpd
   - /usr/sbin/telnetd
   ```

2. **二进制依赖关系**
   ```
   Binary Dependency Graph:
   httpd -> (file:/tmp/config.dat) -> configd
   ```

3. **发现的漏洞警告**
   ```
   [ALERT] Buffer Overflow in /usr/bin/httpd
   Tainted data from socket flows to strcpy() at 0x400123
   ```

4. **统计信息**（如果启用 stats）
   - 分析时间
   - 路径复杂度
   - 发现的数据流数量

---

## 七、常见问题处理

### 7.1 分析卡住不动

**原因：** angr 在某些复杂函数上符号执行爆炸

**解决方案：**
1. 将导致问题的二进制文件添加到 `angr_explode_bins`
2. 使用更简单的固件样本先测试
3. 减少分析范围（在 `bin` 中只指定关键二进制文件）

### 7.2 没有发现边界二进制文件

**原因：** 固件文件系统路径不正确或二进制文件格式不支持

**检查清单：**
```bash
# 1. 验证文件系统路径
ls -la <fw_path>/bin
ls -la <fw_path>/usr/bin

# 2. 检查二进制文件格式
file <fw_path>/usr/bin/httpd

# 3. 手动指定已知的网络服务二进制
# 在配置文件中设置：
"bin": ["./firmware/.../squashfs-root/usr/bin/httpd"]
```

### 7.3 内存不足错误

**解决方案：**
1. 增加系统交换空间
2. 使用更强大的机器
3. 减少并行线程数（修改 `tool/utils.py` 中的 `MAX_THREADS`）

### 7.4 架构不支持

**支持的架构：**
- ARM / ARM64 (AARCH64)
- MIPS / MIPS64
- x86 / x86_64

**不支持的架构：**
- 需要手动移植或使用其他工具

---

## 八、高级技巧

### 8.1 使用 Pickle 缓存加速重复分析

首次分析后，会生成边界二进制的解析缓存：

```bash
# 1. 首次分析
python tool/karonte.py config/MY_VENDOR/my_device.json

# 2. 查找生成的 pickle 文件
find /tmp/pickles -name "*.pk"

# 3. 在配置文件中指定缓存路径
"pickle_parsers": "/tmp/pickles/parser/MY_VENDOR/xxx.pk"

# 4. 再次运行将跳过边界二进制发现阶段
```

### 8.2 指定分析特定二进制文件

如果你已知某个二进制文件存在问题：

```json
{
    "bin": [
        "./firmware/MY_VENDOR/MY_DEVICE/squashfs-root/usr/bin/httpd"
    ],
    "fw_path": "./firmware/MY_VENDOR/MY_DEVICE/squashfs-root",
    ...
}
```

### 8.3 分析 Blob 固件的完整流程

对于 bootloader 或裸机固件：

1. **使用 IDA Pro / Ghidra 手动分析**
   - 确定加载基址 (`base_addr`)
   - 找到处理用户输入的函数地址 (`eg_source_addr`)
   - 识别全局变量地址 (`glob_var`)

2. **配置示例：**
   ```json
   {
       "bin": ["./firmware/bootloader.img"],
       "base_addr": "0x08000000",
       "eg_source_addr": "0x08001234",
       "arch": "ARM",
       "data_keys": [["0x08005000", "UART"]],
       "glob_var": ["0x08010000"],
       "only_string": "True",
       "fw_path": "",
       "pickle_parsers": "",
       "stats": "True",
       "angr_explode_bins": []
   }
   ```

---

## 九、完整操作示例

### 示例：分析 TP-Link 路由器固件

```bash
# 1. 准备固件
mkdir -p firmware/TP_Link/Archer_C7
cd firmware/TP_Link/Archer_C7
wget https://example.com/Archer_C7_V5_200925.bin

# 2. 手动提取（可选）
binwalk -e Archer_C7_V5_200925.bin
cd _Archer_C7_V5_200925.bin.extracted/squashfs-root
pwd  # 假设输出：/path/to/karonte/firmware/TP_Link/Archer_C7/_Archer_C7_V5_200925.bin.extracted/squashfs-root

# 3. 创建配置文件
cd /path/to/karonte
cat > config/TP_Link/archer_c7_v5.json << 'EOF'
{
    "fw_path": "./firmware/TP_Link/Archer_C7/_Archer_C7_V5_200925.bin.extracted/squashfs-root",
    "bin": [],
    "pickle_parsers": "",
    "stats": "True",
    "data_keys": [],
    "angr_explode_bins": [
        "openvpn",
        "wpa_supplicant",
        "vpn",
        "qemu-arm-static"
    ],
    "glob_var": [],
    "arch": "",
    "only_string": "False"
}
EOF

# 4. 运行分析
python tool/karonte.py config/TP_Link/archer_c7_v5.json

# 5. 查看结果
cat /tmp/Karonte.txt_*
```

---

## 十、检查清单

在提交新固件分析前，请确认：

- [ ] 固件已成功提取，包含完整的文件系统
- [ ] 配置文件路径正确（使用相对路径）
- [ ] 依赖已安装（`pip list | grep angr`）
- [ ] 有足够的磁盘空间（至少 10GB）
- [ ] 有足够的内存（建议 16GB+）
- [ ] 已设置合理的超时时间（如果使用脚本）

---

## 十一、参考资料

- **论文：** [KARONTE: Detecting Insecure Multi-binary Interactions in Embedded Firmware (IEEE S&P 2020)](https://www.badnack.it/static/papers/University/karonte.pdf)
- **angr 文档：** https://docs.angr.io/
- **固件数据集：** [Google Drive](https://drive.google.com/file/d/1-VOf-tEpu4LIgyDyZr7bBZCDK-K2DHaj/view?usp=sharing)
- **GitHub：** https://github.com/angr/karonte

---

## 附录：配置文件快速参考

### A. 最小配置（Linux 固件）
```json
{
    "fw_path": "./firmware/path/to/rootfs",
    "bin": [],
    "pickle_parsers": "",
    "stats": "False",
    "data_keys": [],
    "angr_explode_bins": [],
    "glob_var": [],
    "arch": "",
    "only_string": "False"
}
```

### B. 最小配置（Blob 固件）
```json
{
    "bin": ["./firmware/blob.bin"],
    "base_addr": "0x80000000",
    "eg_source_addr": "0x80001000",
    "arch": "ARM",
    "fw_path": "",
    "pickle_parsers": "",
    "stats": "False",
    "data_keys": [],
    "angr_explode_bins": [],
    "glob_var": [],
    "only_string": "False"
}
```

---

**祝分析顺利！如有问题请参考论文或提交 GitHub Issue。**
